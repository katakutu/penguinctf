import base64
import socket
import sys
from time import sleep
import struct

requests_made = 0

def expect(sock, expected, strict=False):
    data = sock.recv(5000)
    #print '"%s"' % data
    if strict:
        if data == expected:
            return True
    else:
        if expected in data:
            return True
#    print("[-] Could not find '%s' in data. Exiting" % expected)
#    exit()

def mutate_block(block, mask):
    # mask in form [-1 ,0xff, 0xca, 0xab, 0x12, 0x34, 0x56, 0x98]
    # -1 means to perform no bit flipping, others means to xor
    new_block = []
    for i in range(len(block)):
        if mask[i] != -1:
            new_block.append(chr(ord(block[i]) ^ mask[i]))
        else:
            new_block.append(block[i])
    return new_block

def decrypt_loop(host, port, message):
    # Make socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    global requests_made
    requests_made += 1

    # Expect banner
    expect(sock, "Your choice:")
    sock.send("3\n")

    # Expect message
    expect(sock, "Please provide your encrypted text:")
    sock.send(message.strip()+"\n")

    # Expect found IV
    expect(sock, "Found the following IV:")

    # Read next line manually
    die = 3
    while True:
        data = sock.recv(5000)
        if "Invalid padding" in data:
            sock.close()
            return "invalid_padding"
        elif "Please enter the admin password:" in data:
            sock.sendall("\n")
            sock.close()
            return "valid_ciphertext"
        elif "Invalid ciphertext format." in data:
            sock.close()
            return "invalid_ciphertext"
        if die == 0:
            return None
        else:
            die -= 1

def exploit(iv, message, host, port):
    msg_bytes  = base64.decodestring(message)
    msg_block = [msg_bytes[i:i+8] for i in range(0, len(msg_bytes), 8)]
    working_block = list(msg_block[-2]) # Deep copy and listify
    last_block = list(msg_block[-1])

    # search for padding length from c_0 to c_7 to find maximum amount
    # of information in shortest time.
    padding_length = -1
    for i in range(8):
        mask = [-1]*i + [0xff] + [-1]*(7-i)
        mutated_block  = mutate_block(working_block, mask)
        mutated_string = msg_bytes[:-16] + "".join(mutated_block) + msg_bytes[-8:]
        msg = "%s:%s" % (iv, base64.encodestring(mutated_string).replace("\n", ""))
        result = decrypt_loop(host, port, msg)
        if result == "invalid_padding":
            padding_length = 8 - i
            break
    print("[+] Found padding length: %d" % padding_length)

    # Recover length of key for the found length of padding:
    # This is based on the principle that:
    # C1_i ^ C2_i ^ K_i = P_i
    # K_i = P_i ^ C1_i ^ C2_i
    # Where K is the key, P is the plaintext, C is our ciphertext
    # C1 is cipher text block one (which we modify)
    # C2 is cipher text block two which is modified during decryption
    # We know P since we have the length of the padding and the
    # content is simply the length of the padding for each byte
    # This attack works because the scheme of encryption is insecure
    # and has none of the confusion or diffusion properties.
    key = [-1, -1, -1, -1, -1, -1, -1, -1]
    for i in range(7, padding_length-1, -1):
        key[i] = ord(working_block[i])^ord(last_block[i])^padding_length
    key_found = padding_length
    plaintext = [-1]*(8-key_found) + [padding_length]*key_found
    print("[+] Recovered %d bytes of key: %s" % (key_found, str(key)))

    # To recover the rest of key, we have to have a way to set the 
    # plaintext to any arbitrary value we want. At least for the 
    # P_i we have the key to.
    # To do this we simply perform the following operation:
    # (K_i ^ C1_i ^ C2_i) ^ P_i = 0
    # Since a value xor with 0 is the value, we perform:
    # (K_i ^ P_i ^ C1_i ^ C2_i) P_i ^ A_i = A_i
    # Since the K, C1, and C2 are applied through the decryption process,
    # we need to inject the P_i and A_i
    for i in range((8-padding_length), 0, -1):
        new_padding_length = padding_length+(padding_length-i)+1
        byte_position = i-1
        key_mask = []
        for k in range(key_found):
            key_mask.append(plaintext[k+(8-key_found)] ^ new_padding_length)
        print("[+] Attempting to recover the key in position %d" % byte_position)
        for j in range(0xff+1):
            mask = [-1]*(byte_position) + [j] + key_mask
            mutated_block  = mutate_block(working_block, mask)
            mutated_string = msg_bytes[:-16] + "".join(mutated_block) + msg_bytes[-8:]
            msg = "%s:%s" % (iv, base64.encodestring(mutated_string).replace("\n", ""))
            result = decrypt_loop(host, port, msg)
            if result == "valid_ciphertext":
                plain_byte = j ^ new_padding_length
                plaintext[byte_position] = plain_byte
                key_byte = ord(working_block[byte_position])^ord(last_block[byte_position])^plain_byte
                key[byte_position] = key_byte
                key_found += 1
                print("[+] Found key in position %d: %d" % (byte_position, key_byte))
                break

    key_val = struct.unpack(">Q", "".join(map(chr, key)))[0]
    global requests_made
    print("[+] Full key recovered! Completed in %d requests." % requests_made)
    print("[+] Please use the following key to decrypt your message: %x" % key_val)


def main():
    print "WhatVase? Challenge Exploit by amon"
    if len(sys.argv) != 3:
        print("usage: ./%s host:port valid_ciphertext" % sys.argv[0])
        exit()


    data = sys.argv[2]
    iv, message = data.split(":")

    host, port = sys.argv[1].split(":")
    port = int(port)

    print("[+] Launching exploit against %s:%d." % (host, port))
    exploit(iv, message, host, port)


if __name__ == "__main__":
    main()